FROM: Steven A Rowe <sar...@syr.edu>
SUBJECT: RE: InverseWildcardQuery
DATE: 30 Jul 2010

Hi Justin,

> > an example
> 
> PerFieldAnalyzerWrapper analyzers =
>     new PerFieldAnalyzerWrapper(new KeywordAnalyzer());
> // myfield defaults to KeywordAnalyzer
> analyzers.addAnalyzer("content", new SnowballAnalyzer(luceneVersion, "English"));
> // analyzers affects the indexed field value
> IndexWriter writer = new IndexWriter(dir, analyzers, true, mfl);
> // analyzers affects the parsed query string
> QueryParser parser = new QueryParser(luceneVersion, "myfield", analyzers);
> parser.setAllowLeadingWildcard(true);
> Query query = parser.parse("*:* AND -myfield:\"*foo*\"");
> // What about an Analyzer to match field value to the query at search time?
> ScoreDoc[] docs = searcher.search(query, null, 1000).scoreDocs;

I'm afraid that this "example" doesn't help me - my reading of "What about an Analyzer to
match field value to the query at search time?" is that you want what Lucene already does,
but that's clearly not true. 

> > An inverse query would require rewriting, too, I think.
> 
> Why would implementing a new Query class requires document changes in the
> index.

Query rewriting is what I meant (and what I thought you meant).  What do you mean when you
say "rewriting" - how would it affect indexed documents?

> > Can you turn those prefixes into field names
> 
> No, the prefixes are not discrete. Multiple field values could start with
> the same prefix.

Hmm, again with the misunderstanding on my part - how is it that "prefixes are not discrete"
and also "there are a limited number of prefixes ... (10ish)"?  And why is it important that
multiple field values could start with the same prefix?  Why couldn't you just store all of
those that share the same prefix in the field corresponding to the prefix?

Steve

