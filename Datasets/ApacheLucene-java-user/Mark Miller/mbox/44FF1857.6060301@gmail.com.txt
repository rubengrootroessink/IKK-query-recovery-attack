FROM: Mark Miller <markrmil...@gmail.com>
SUBJECT: Re: parser question
DATE: 6 Sep 2006

yes its ANDing them.  Doing the query 'software engineer', 'software OR 
engineer', 'software AND engineer' all return the same results.  the 
generated queries for them respectively are '(field:software 
field:engineer)', '(field:software field:engineer)' and 
'(+field:software +field:engineer)'.  I do set the default operator to 
AND and i'm using the MultiFieldQueryParser if that makes a difference 
(it was doing the same thing with the QueryParser as well).


Chris Salem
440.946.5214 x5458
chris@mainsequence.net <mailto:chris@mainsequence.net>
 
------

If you keep the exchange on the list you'll get the benefit of someone 
smarter and more experienced than me stepping in.

See if the following code does not convince  you that it works 
correctly.  I am using Lucene 2.0. Maybe there is a bug in an earlier 
version, but I doubt it:

import java.io.IOException;
import java.util.Date;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.WhitespaceAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.queryParser.QueryParser;
import org.apache.lucene.queryParser.QueryParser.Operator;
import org.apache.lucene.search.Hits;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.store.RAMDirectory;


public class TestWildCardFilter {
    private static RAMDirectory directory;

    private static Analyzer analyzer;

    public static void main(String[] args) {
        setupIndex();
       
        try {
            search("coconut stone");
            search("coconut OR stone");
            search("coconut AND stone");
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private static void setupIndex() {
        directory = new RAMDirectory();

        analyzer = new WhitespaceAnalyzer();

        IndexWriter writer;

        try {
            writer = new IndexWriter(directory, analyzer, true);

            Document doc = new Document();
            doc.add(new Field("allFields",
                    "levely bunch of coconuts",
                    Field.Store.NO, Field.Index.TOKENIZED));

            writer.addDocument(doc);


            doc = new Document();
            doc.add(new Field("allFields", "crazy rolling stone",
                    Field.Store.NO, Field.Index.TOKENIZED));
            writer.addDocument(doc);
           
            doc = new Document();
            doc.add(new Field("allFields", "rolling stone done in by 
coconut",
                    Field.Store.NO, Field.Index.TOKENIZED));
            writer.addDocument(doc);


            writer.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
   
    public static int search(String q) throws Exception {
        IndexSearcher is = new IndexSearcher(directory);

        QueryParser qp = new QueryParser("allFields", analyzer);
        qp.setDefaultOperator(Operator.AND);
        Query query = qp.parse(q);
       
        long start = new Date().getTime();
        Hits hits = is.search(query);
        long end = new Date().getTime();
        System.err.println("\nquery: " + query.toString());
        System.err.println("Found " + hits.length() + " document(s) (in " +
            (end - start) + " milliseconds) that matched query '" + q + 
"':");
       
        return hits.length();
    }
}


---------------------------------------------------------------------
To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org
For additional commands, e-mail: java-user-help@lucene.apache.org


