FROM: Mark Miller <markrmil...@gmail.com>
SUBJECT: Re: Technology Preview of new Lucene QueryParser
DATE: 22 Jan 2007

As I humbly ran into. I thought of '-a', and 'a' but hadn't thought too 
far ahead. It covers enough ground to satisfy me for now though. Mixing 
real precedence and unary operators is something I experimented with a 
little a few months back and couldn't find anything good. This is my 
first parser so I am sure I am a bit limited in this regard. Unary 
syntax equivalence will have to be pushed aside for now. Thanks for all 
your input Hoss.

- Mark

Chris Hostetter wrote:
> : With my syntax you can get real precedence that mixes with how no
> : precedence (Lucene's unary operators) works. No precedence is created by
> : allowing you to make any operator resolve first...any operator that
> : resolves first connected with another operator that resolves first will
> : behave as if neither has precedence over the other and generate a single
> : BooleanQuery.
>
> what i was trying to get at is that i don't think precedence is really the
> issue -- it's the lack of unary operators.  If the only way to get a
> single BooleanQuery is to use operators that have the exact same
> precedence, and all operators are binary, then how to you create the
> equivilent of QueryParser "+a b c -d -e" ? ... if i remember your syntax
> correctly the only way to match the same documents is...
> 	"a & ( b | c ) ! d ! e"
>
> ...but it won't score the same way because the parens force a nested
> boolean query to be created.
>
>
> -Hoss
>
>
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org
> For additional commands, e-mail: java-user-help@lucene.apache.org
>
>
>   

---------------------------------------------------------------------
To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org
For additional commands, e-mail: java-user-help@lucene.apache.org


