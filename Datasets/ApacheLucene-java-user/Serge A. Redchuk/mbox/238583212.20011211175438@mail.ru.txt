FROM: "Serge A. Redchuk" <b...@mail.ru>
SUBJECT: Re[4]: WildcardQuery
DATE: 11 Dec 2001

Hello Benjamin,

Tuesday, December 11, 2001, 5:28:46 PM, you wrote:

BK> Sergej

BK> Could you please provide a sample code to demonstrate how you did that?

Of course:
(please correct me if I'll become wrong finally, but hope that I have
not hallucinations :-)

// search function
void searchBooleanWildcard( HashMap terms, boolean req ) throws IOException {
    System.out.println( "Boolean wildcard search:" );
    HashSet entries = new HashSet( terms.entrySet() );
    BooleanQuery bQuery = new BooleanQuery();
    for( Iterator it = entries.iterator(); it.hasNext(); ){
      Object itn = it.next();
      String where = (String)((Map.Entry)itn).getKey();
      String what = (String)((Map.Entry)itn).getValue();
      WildcardQuery wQuery = new WildcardQuery( new Term( where, what ) );
      //System.out.println( "Add to query: [" + where + ", " + what + "]" );
      bQuery.add( wQuery, req, false );
    }
    System.out.println( "built query: " + bQuery.toString( "body" ) );
    Searcher searcher = new IndexSearcher( rdir );
    this.showHits( searcher.search( bQuery ) );
  }

// used at the end of the function above
private void showHits( Hits hits ) throws IOException {
    for( int i=0; i<hits.length(); i++ ){
      System.out.println( hits.doc( i ).get( "path" ) + ":"
        + hits.doc( i ).get( "body" ) + "; Score: " + hits.score( i ) );
    };
    System.out.println( "" );
  }

Please do not forget that HashMap can't contain more then one values
with the same key. So the function searchBooleanWildcard(HashMap hmap) can
combine search request only for different field names. (Hope that this
explaination is quite clear).

For example if we built search directories from 3 type of fields:
["body", "..."], ["path", "..."], ["type", "..."]
we can add no more then 3 pairs to HashMap hmap.

And an example of search:
HashMap phQeryTerms = new HashMap();
phQeryTerms.put( "body", "*e*n" );
sr.searchBooleanWildcard( phQeryTerms, true );

Corresponding output:
Boolean wildcard search:
built query: +*e*n
news7:bean; Score: 1.0
news73:beeemN; Score: 0.25
news71:jEaN; Score: 0.25

Of course, when the next pairs are indexed
( path , body ):
"news7", "bean"
"news71", "jEaN"
"news72", "lion"
"news73", "beeemN"
  
BK> Best regards

BK> Benjamin

>> -----Original Message-----
>> From: Serge A. Redchuk [mailto:bitl@mail.ru]
>> Sent: 11 December 2001 15:24
>> To: lucene-user@jakarta.apache.org
>> Subject: Re[2]: WildcardQuery
>> 
>> 
>> Hello Otis,
>> 
>> Strongly can not agree with you, because I really _can_ search for
>> anything like '*new*'.
>> 
>> _Simply_Beacuse_I_have_working_code_that_do_it_
>> 
>> Here's a slice of output of my program:
>> 
>> Boolean wildcard search:
>> built query: bee*
>> news41:beem;
>> news42:beem;
>> news4:beem;
>> 
>> Boolean wildcard search:
>> built query: *ee
>> f3:qthree;
>> 
>> Boolean wildcard search:
>> built query: +be* +path:*ws42
>> news42:beem;
>> 
>> Boolean wildcard search:
>> built query: +path:*ws4 +be*
>> news4:beem;
>> 
>> As you can see the first search returned 3 entries, but the 3-rd -
>> only one. As well as the 4-th.
>> And the 2-nd search returned only entry "f3:qthree;"
>> (as we've expected: "built query: *ee").
>> 
>> And I've achieve it combining WildcardQueries in BooleanQuery, but
>> did not achieve it by simple call of QueryParser.parser.
>> 
>> Tuesday, December 11, 2001, 4:22:04 PM, you wrote:
>> 
>> OG> If I understand you correctly, you tried to search for '*new*'.  I
>> OG> believe you can't use an asterisk (*) as the first query of the query
>> OG> term. So, new* is valid, while *new or *new* is not.
>> 
>> OG> Otis
>> 
>> OG> --- "Serge A. Redchuk" <bitl@mail.ru> wrote:
>> >> Hello sampreet,
>> >> 
>> >> Tuesday, December 11, 2001, 6:44:29 AM, you wrote:
>> >> 
>> >> sic> Hi All,
>> >> 
>> >> sic> This must be simple enough, but can anyone please explain me
>> >> when a
>> >> sic> WildcardQuery is created in QueryParser i.e. what special
>> >> characters in the
>> >> sic> query string are required to build a WildcardQuery within
>> >> QueryParser?
>> >> 
>> >> Moreover, when I achieved complex search like this: "path:*new*
>> >> comp*"
>> >> by combining WildcardQueries in BooleanQuery (NOT BY QueryParser),
>> >> and
>> >> then got that query using boolq.toString(...); - the QueryParser
>> >> COULD
>> >> NOT parse this string !!!
>> >> 
>> >> Is not it strange ? :
>> >> 
>> >>    QueryParser.parse( bquery.toString( ... ) ) ....  - do not work
>> >> :-(
>> >> 

-- 
Best regards,
 Serge                            mailto:bitl@mail.ru


--
To unsubscribe, e-mail:   <mailto:lucene-user-unsubscribe@jakarta.apache.org>
For additional commands, e-mail: <mailto:lucene-user-help@jakarta.apache.org>


