FROM: Akmal Sarhan ...@byteaction.de>
SUBJECT: Re: Boosting documents
DATE: 27 Jul 2004

Hallo,

I have followed your suggestion but I am not sure how it should be done
to achieve the following:
I want when I do the following search to have the score calculated so
that those with nr of kids higher get a better score and the less kids,
the less score , notice that I still want to get all documents

thanks for any input

import java.io.IOException;

import org.apache.lucene.analysis.SimpleAnalyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.Term;
import org.apache.lucene.queryParser.ParseException;
import org.apache.lucene.queryParser.QueryParser;
import org.apache.lucene.search.DefaultSimilarity;
import org.apache.lucene.search.Hits;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.Searcher;
import org.apache.lucene.store.RAMDirectory;

public class TestMatching
{

    protected float f;

    public static void main(String[] args) throws IOException,
ParseException
    {

        RAMDirectory store = new RAMDirectory();
        IndexWriter writer = new IndexWriter(store, new
SimpleAnalyzer(), true);

        Field f1 = Field.Text("field", "word");
        Field kids1 = Field.Keyword("kids", "2");
        Field kids2 = Field.Keyword("kids", "3");
        Field kids3 = Field.Keyword("kids", "4");

        Document d1 = new Document();
        Document d2 = new Document();
        Document d3 = new Document();

        d1.add(f1);
        d2.add(f1);
        d3.add(f1);
        d1.add(kids1);
        d2.add(kids2);
        d3.add(kids3);

        d1.add(f1);
        writer.addDocument(d1);
        writer.addDocument(d2);
        writer.addDocument(d3);

        writer.optimize();
        writer.close();

        Searcher s = new IndexSearcher(store);

        s.setSimilarity(new DefaultSimilarity() {

            public float idf(Term term, Searcher searcher) throws
IOException
            {
                String string = term.text();
                String string2 = term.field();
                float f = 0.0f;
                if (term.field().equals("kids"))
                {
                    // and now ??
                } else
                {
                    f = idf(searcher.docFreq(term), searcher.maxDoc());
                }

                return f;
            }
        });
        Query query = QueryParser.parse("field:word kids:5", "field",
new StandardAnalyzer());
        Hits hits = s.search(query);

        for (int i = 0; i < hits.length(); ++i)
        {
            Document doc = hits.doc(i);
            System.out.println(i + " " + hits.score(i));

        }

    }
}

Am Mo, den 26.07.2004 schrieb Doug Cutting um 20:14:
> Rob Clews wrote:
> > I want to do the same, set a boost for a field containing a date that
> > lowers as the date is further from now, is there any way I could do
> > this?
> 
> You could implement Similarity.idf(Term, Searcher) to, when 
> Term.field().equals("date"), return a value that is greater for more 
> recent dates.
> 
> Doug
> 
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: lucene-user-unsubscribe@jakarta.apache.org
> For additional commands, e-mail: lucene-user-help@jakarta.apache.org
> 
> 
> !EXCUBATOR:41054a2d101985076154790!
> 


---------------------------------------------------------------------
To unsubscribe, e-mail: lucene-user-unsubscribe@jakarta.apache.org
For additional commands, e-mail: lucene-user-help@jakarta.apache.org


