FROM: "Jeff Wong" <jeffw...@savagebeast.com>
SUBJECT: Re: building a search query
DATE: 9 Jun 2004

Well, I can offer you advice on 2 fronts:

1)  I recommend against using the QueryParser unless you have nothing to add
to the users input.  In my situation, I was generating Lucene query object
using the query parser.  It was kind of cumbersome because I was doing
things like joining some terms with ORs and ANDs within parentheses.  Since
I was using Python to prototype at the time,  it was just more convenient to
do string manipulation and pass it to the QueryParser.  However, when you do
that, you risk introducing another class of bugs because you can pass a
string to QueryParser which is syntactically incorrect. You have to be
careful to escape characters which having meaning to the Lucene QueryParser.

Later on, I was combining terms and creating new query terms
programmatically and it was easier to do this on the object Query object
that came out of the QueryParser.  It's kind of disorganized right now.  If
I had to go back and do it again, I would have just left out the
QueryParser.

2) Also,  you should be wary of the possibility that your users may not know
Boolean logic.  AND and OR may have different meanings for them.  For most
people, AND is an inclusive operator and OR is basically XOR.  It may seem
strange to you, but it's kind of like those optical illusions.  Is the
picture of an old woman or a young lady?  Is that a wine glass or two people
in profile?


To answer your question about using the BooleanQuery object,  you only need
a single clause object to connect multiple terms.

To make a BooleanQuery like this:
A OR B OR C


q = new BooleanQuery()
q.add( a, false, false)
q.add( b, false, false)
q.add( c, false, false)



----- Original Message ----- 
From: "Ben Pryor" <BPryor@widen.com>
To: <lucene-user@jakarta.apache.org>
Sent: Wednesday, June 09, 2004 2:37 PM
Subject: building a search query


> I am working on a UI to allow a user to build a search query. The user
> creates individual "clauses", each of which is basically a simple search
> query. The user selects boolean operators (AND, OR, NOT), to connect these
> clauses. When the user is finished constructing the search, there will be
N
> clauses and N-1 boolean connectors.
>
> Each clause is backed by an object that knows how to generate a Lucene
Query
> from the clause. The objective is to combine the clauses and the boolean
> operators into a BooleanQuery.
>
> What is the best way to programmatically make the final BooleanQuery
object?
> It seems there is a modeling mismatch: the user sees N clauses connected
> with N-1 connectors, but the BooleanQuery will require N Querys with each
> Query having its own required and prohibited flags set correctly.
>
> I looked briefly at the QueryParser class - it appears to have logic to
> bridge these two different ways of modeling complex queries (in the
> addClause method). Is this the best approach? What have others done?


---------------------------------------------------------------------
To unsubscribe, e-mail: lucene-user-unsubscribe@jakarta.apache.org
For additional commands, e-mail: lucene-user-help@jakarta.apache.org


