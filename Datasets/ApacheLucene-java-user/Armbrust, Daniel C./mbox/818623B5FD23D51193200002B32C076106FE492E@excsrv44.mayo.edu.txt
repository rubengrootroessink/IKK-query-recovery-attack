FROM: "Armbrust, Daniel C." <Armbrust.Dan...@mayo.edu>
SUBJECT: Lucene Speed under diff JVMs
DATE: 5 Dec 2002

This may be of use to people who want to make lucene index faster.  Also, I'm curious as to
what JVM most people run Lucene under, and if anyone else has seen results like this:

I'm using the class that Otis wrote (see message from about 3 weeks ago) for testing the scalability
of lucene (more results on that later) and I first tried running it under different versions
of Java, to see where it runs the fastest.  The class simply creates an index out of randomly
generated documents. 

All of the following were running on a dual CPU 1 GHz PIII Windows 2000 machine that wasn't
doing much else during the benchmark.  The indexing program was single threaded, so it only
used one of the processors of the machine.

java version "1.3.1_04"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.3.1_04-b02)
Java HotSpot(TM) Client VM (build 1.3.1_04-b02, mixed mode)

42 seconds/1000 documents

java version "1.4.1"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1-b21)
Java HotSpot(TM) Client VM (build 1.4.1-b21, mixed mode)

42 seconds/1000 documents

Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01)
BEA WebLogic JRockit(R) Virtual Machine (build 8.0_Beta-1.4.1_01-win32-CROSIS-20021105-1617,
Native Threads, Generational Concurrent Garbage Collector)

35 seconds/1000 documents

java version "1.3.1"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.3.1)
Classic VM (build 1.3.1, J2RE 1.3.1 IBM Windows 32 build cn131-20020403 (JIT enabled: jitc))

27 seconds/1000 documents


As you can see, the IBM jvm pretty much smoked Suns.  And beat out JRockit as well.  Just
a hunch, but it wouldn't surprise me if search times were also faster under the IBM jdk. 
Has anyone else come to this conclusion?


Dan

--
To unsubscribe, e-mail:   <mailto:lucene-user-unsubscribe@jakarta.apache.org>
For additional commands, e-mail: <mailto:lucene-user-help@jakarta.apache.org>


